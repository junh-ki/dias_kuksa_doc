********************************
DIAS Extension: SAE J1939 Option
********************************

Introduction to SAE J1939
#########################

Society of Automotive Engineers standard SAE J1939 is the vehicle bus recommended practice used for communication and diagnostics among vehicle components. Originating in the car and heavy-duty truck industry in the United States, it is now widely used in other parts of the world. SAE J1939 is a higher-layer protocol (e.g., an add-on software) that uses the CAN Bus technology as a physical layer. In addition to the standard CAN Bus capabilities, SAE J1939 supports node addresses, and it can deliver data frames longer than 8 bytes (in fact, up to 1785 bytes).

Since DIAS's demonstrator vehicle is a Ford Otosan truck that uses SAE J1939 standard, it is necessary for KUKSA to adapt the standard. 

The normal DBC file is used to apply identifying names, scaling, offsets, and defining information, to data transmitted **within a CAN frame**. The J1939 DBC file is designed to serve the same purposes but aiming at data transmitted **within a Parameter Group Number (PGN) unit**. This is due to the fact that some data frames are delievered in more than one CAN frame depending on the PGN's data length in J1939. 

To simply put, one can take a look at one PGN example. The following PGN-65251 information is captured in the official SAE J1939-71 documentation revised in 2011-03 (`PDF Download Link <http://gost-snip.su/download/1sae_j1939_71_vehicle_application_layer_>`_).

.. figure:: /_images/j1939/pgn_65251.PNG
    :width: 600
    :align: center

PGN-65251 defines the engine configuration and consists of 39 bytes as stated in "Data Length". This means that to receive the complete information of PGN-65251, at least 6 CAN frames are required when considering the length of a single CAN frame is 8 bytes: 

:math:`6 = 1 * TP.BAM + 5 * TP.DT`

- A Transfer Protocol Broadcast Announce Message (TP.BAM) is used to inform all the nodes (e.g., Raspberry-Pi) of the network that a large message is about to be broadcast and defines the parameter group (The Target PGN) and the number of total packets to be sent. After TP.BAM is sent, a set of TP.DT messages are sent at specific time intervals.
- A Transfer Protocol Data Transfer (TP.DT) is an individual packet of a multipacket message transfer. It is used for the transfer of data associated with parameter groups that have more than 8 bytes of data (e.g., PGN-65251: 39 bytes).

For example, one TP.BAM and three TP.DT messages would be sent to deliver a parameter group that has more than 20 bytes (PGN-65260) as illustrated below:

.. figure:: /_images/j1939/j1939_transport_protocol.png
    :width: 450
    :align: center

To conform the transport protocol, there are a lot of concepts defined in the J1939 documentation. One can look into the documentation to understand the concepts in depth. However, the general premise is simple: **Raw CAN frames are processed to produce PGN data that should be decoded into CAN signals and later consumed by an in-vehicle application.** Having said that, finding an existing J1939 library that can convert raw CAN frames to PGN data should be the first step. Since `dbcfeeder.py` is written in Python, it makes sense to choose the library written in the same language.

`The J1939 Python package <https://pypi.org/project/j1939/>`_ converts raw CAN frames to PGN data and make it available for use. The following figures compare two scenarios where `dbcfeeder.py` reads CAN signals without and with J1939.

.. figure:: /_images/j1939/dbcreader_schema.png
    :width: 450
    :align: center

Without J1939, `dbcfeeder.py` gets decoded CAN singals through `dbcreader.py` that reads raw CAN messages directly from a CAN interface (e.g., `can0` or `vcan0`).

.. figure:: /_images/j1939/j1939reader_schema.png
    :width: 600
    :align: center

With J1939, `dbcfeeder.py` gets decoded CAN singals through `j1939reader.py` (`source <https://github.com/junh-ki/dias_kuksa/blob/master/utils/in-vehicle/j1939feeder/j1939reader.py>`_) that reads PGN messages from the ElectronicControlUnit (ECU) class of the `j1939` python package that converts raw CAN frames to PGN data.
The ControllerApplications (CA) class from the `j1939` python package utilizes the ECU class's functionalities to derive PGN data and `j1939reader.py` is a sub-class of the CA class. 

At the time of writing this documentation, the following features are available from the `j1939` python package according to `here <https://pypi.org/project/j1939/>`_:

- One ElectronicControlUnit (ECU) can hold multiple ControllerApplications (CA)
- ECU (CA) Naming according SAE J1939/81
- Full support of transport protocol according SAE J1939/21 for sending and receiveing
    - Message Packaging and Reassembly (up to 1785 bytes)
        - Transfer Protocol Transfer Data (TP.DT)
        - Transfer Protocol Communication Management (TP.CM)
    - Multi-Packet Broadcasts
        - Broadcast Announce Message (TP.BAM)



Implementation to j1939reader.py
################################

A sophisticated example of `j1939.ControllerApplication` that receives PGN messages from `j1939.ElectronicControlUnit` is already introduced `here <https://pypi.org/project/j1939/>`_ as `OwnCaToProduceCyclicMessages`. When running `OwnCaToProduceCyclicMessages` and a J1939 CAN log file together, the following messages can be shown on the `OwnCaToProduceCyclicMessages`'s terminal.

.. figure:: /_images/j1939/OwnCaToProduceCyclicMessages.PNG
    :width: 300
    :align: center

As shown above, each message prints out the number and the length of a PGN that has been read. These messages are produced from a function called `on_message`.

.. figure:: /_images/j1939/on_message.PNG
    :width: 300
    :align: center

As already mentioned, the general premise is that **Raw CAN frames are processed to produce PGN data that should be decoded into CAN signals and later consumed by an in-vehicle application.** Here we can divide the premise into three requirements:

A. Getting PGN data
B. Decoding PGN data into CAN signals
C. Getting the decoded CAN signals available on the target in-vehicle application (e.g., `dbcfeeder.py`)

It is already possible to receive PGN data through `OwnCaToProduceCyclicMessages` (`code <https://pypi.org/project/j1939/>`_). Also, `dbcreader.py` (`code <https://github.com/eclipse/kuksa.val/blob/master/clients/feeder/dbc2val/dbcreader.py>`_) can be reused for getting the decoded signals ready for the in-vehicle application. 



j1939reader.py in dbcfeeder.py
==============================

1. dbcfeeder.py without J1939
-----------------------------

.. figure:: /_images/j1939/dbcreader_schema.png
    :width: 450
    :align: center

.. figure:: /_images/j1939/dbcfeeder_import.PNG
    :width: 200
    :align: center

.. figure:: /_images/j1939/dbcfeeder_lines.PNG
    :width: 415
    :align: center

In the case without J1939, `dbcfeeder.py` imports `dbcreader.py` and passes the required arguments when creating an instance of `dbcreader.DBCReader`. Then the `dbcreader.DBCReader` instance starts a thread by running `start_listening()` and receiving CAN frames through its connected CAN interface (`cfg['can.port']`).

2. dbcfeeder.py with J1939
--------------------------

.. figure:: /_images/j1939/j1939reader_schema.png
    :width: 600
    :align: center

.. figure:: /_images/j1939/dbcfeeder_import_modified.PNG
    :width: 200
    :align: center

.. figure:: /_images/j1939/dbcfeeder_lines_modified.PNG
    :width: 415
    :align: center

Likewise, in the case with J1939, `dbcfeeder.py` imports `j1939reader.py` instead of `dbcreader.py` and passes the required arguments when creating an instance of `j1939reader.J1939Reader`. Then the `j1939reader.J1939Reader` instance starts a thread by running `start_listening()` and receiving PGN data through a `j1939.ElectronicControlUnit` instance that is connected to the passed CAN interface (`cfg['can.port']`).



Decoding PGN Data with j1939reader.py
=====================================

`j1939reader.py` (`code <https://github.com/junh-ki/dias_kuksa/blob/master/utils/in-vehicle/j1939feeder/j1939reader.py>`_) reuses `OwnCaToProduceCyclicMessages` and `dbcreader.py` for the requirement A and C with the add-on PGN decode functionality for the requirement B.

.. figure:: /_images/j1939/start_listening.PNG
    :width: 400
    :align: center

`start_listening` creates a `j1939.ElectronicControlUnit` instance and connects it to the passed CAN interface (`cfg['can.port']`). Then the ECU instance adds the current `j1939reader.J1939Reader` (precisely, `j1939.ControllerApplication` inherited by `j1939reader.J1939Reader`) instance and starts a thread of it. After running `start_listening`, the ECU instance can start reading raw CAN frames from the connected CAN interface, convert them into PGN data and send the result to a callback function, `on_message`, of the `j1939reader.J1939Reader` instance. 

.. figure:: /_images/j1939/on_message_modified.PNG
    :width: 300
    :align: center

The callback function, `on_message`, receives PGN data and finds a corresponding CAN message in `self.db` by running `identify_message`. If the return value of `identify_message` is not `None`, it means that the observed PGN has the corresponding message and thus it iterates the list of signals of the message and decodes each signal and put the result in `self.queue` by running `put_signal_in_queue`.

.. figure:: /_images/j1939/identify_message.PNG
    :width: 310
    :align: center

`identify_message` examines the database instance (`self.db`) that has been built with the passed DBC file (`cfg['vss.dbcfile']`) to get a message that corresponds to the observed PGN. Because CAN messages come in the form of a hex code,

.. figure:: /_images/j1939/put_signal_in_queue.PNG
    :width: 533
    :align: center

the passed queue (`self.queue`)

.. figure:: /_images/j1939/decode_signal.PNG
    :width: 514
    :align: center



.. figure:: /_images/j1939/decode_2bytes.PNG
    :width: 415
    :align: center





Running dbcfeeder.py with j1939reader.py
########################################

.. STEPS TO USE dbcfeeder.py with J1939


